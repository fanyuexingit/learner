# 继 承（面向对象特征之一）
* 含义：
* 好处：
    1. 提高了代码的复用性。
    2. 让类与类之间产生了关系，提供了另一个特征多态的前提。

* 父类
```text
父类的由来：其实是由多个类不断向上抽取共性内容而来的。
java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。
 
单继承：一个类只能有一个父类。
多继承：一个类可以有多个父类。

为什么不支持多继承呢？
因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。
但是java支持多重继承。A继承B  B继承C  C继承D。
多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。
所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。
简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。 
```

* 子父类出现后，类中的成员都有了哪些特点：
```text
1：成员变量。
　　当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。
　　如果想要调用父类中的属性值，需要使用一个关键字：super 
　　This：代表是本类类型的对象引用。
　　Super：代表是子类所属的父类中的内存空间引用。
　　注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
2：成员函数。
　　当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)
　　什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。
3：构造函数。
　　发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?
　　原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();
　　super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。
　　为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)
　　　　因为子类继承父类，会继承到父类中的数据，必须要看父类是如何对自己的数据进行初始化的。
　　　　所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

注意：
子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 
如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。
如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。

问题：super()和this()是否可以同时出现的构造函数中。
两个语句只能有一个定义在第一行，所以只能出现其中一个。

super()或者this():为什么一定要定义在第一行？
因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。
```

* 继承的细节
```text
什么时候使用继承呢？
    当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。
    英文书中，所属关系：" is a "
    注意：不要仅仅为了获取其他类中的已有成员进行继承。
    所以判断所属关系，可以简单看，
    如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。

在方法覆盖时，注意两点：
    1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。
    2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)
 
继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。
    这时如何解决问题呢？介绍一个关键字，final:最终。
    final特点：
    　　　　1：这个关键字是一个修饰符，可以修饰类，方法，变量。
    　　　　2：被final修饰的类是一个最终类，不可以被继承。
    　　　　3：被final修饰的方法是一个最终方法，不可以被覆盖。
    　　　　4：被final修饰的变量是一个常量，只能赋值一次。
　　其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。
　　不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。
```

* 抽象类: abstract
```text
抽象：不具体。抽象类表象体现。
在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。
抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。

抽象类的特点：
　　1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。
　　2：抽象方法只定义方法声明，并不定义方法实现。
　　3：抽象类不可以被创建对象(实例化)。
　　4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

抽象类的细节：
　　1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。
　　2：抽象类中是否可以定义非抽象方法？
　　　　可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。
　　3：抽象关键字abstract和哪些不可以共存？final , private , static 
　　4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。
```

* 模板方法设计模式：
```text
解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
　　abstract class GetTime{
　　　　public final void getTime(){ 　　//此功能如果不需要复写，可加final限定
　　　　　　long start = System.currentTimeMillis();
　　　　　　code(); 　　//不确定的功能部分，提取出来，通过抽象方法实现
　　　　　　long end = System.currentTimeMillis();
　　　　　　System.out.println("毫秒是："+(end—start));
　　　　}
　　　　public abstract void code(); 　　//抽象不确定的功能，让子类复写实现
　　}
　　class SubDemo extends GetTime{
　　　　public void code(){ 　　//子类复写功能方法
　　　　　　for(int y=0; y<1000; y++){
　　　　　　　　System.out.println("y");
　　　　　　}
　　　　}
　　}
```

* 接 口：★★★★★
```text
1. 是用关键字interface定义的。
2. 接口中包含的成员，最常见的有全局常量、抽象方法。
　　注意：接口中的成员都有固定的修饰符。
　　1. 成员变量：public static final 
　　2. 成员方法：public abstract   
　　interface Inter{
       public static final int x = 3;
       public abstract void show();
    }
3. 接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。
4. 类与类之间存在着继承关系，类与接口中间存在的是实现关系。  
　　继承用extends  ；实现用implements ；
5. 接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。 
6. 一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。
7. 其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。

接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）
　　1：接口是对外提供的规则。
　　2：接口是功能的扩展。
　　3：接口的出现降低了耦合性。
```
 
* 抽象类与接口
```text
抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。
　　接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。
　　抽象类和接口的共性：都是不断向上抽取的结果。
　　抽象类和接口的区别：
　　　　1：抽象类只能被继承，而且只能单继承。
　　　　　　接口需要被实现，而且可以多实现。 
　　　　2：抽象类中可以定义非抽象方法，子类可以直接继承使用。
　　　　　　接口中都有抽象方法，需要子类去实现。
　　　　3：抽象类使用的是  is a 关系。
　　　　　　接口使用的 like a 关系。 
　　　　4：抽象类的成员修饰符可以自定义。
　　　　　　接口中的成员修饰符是固定的。全都是public的。
 
　　在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。 
``` 
——————————————————————————————————————————————————————